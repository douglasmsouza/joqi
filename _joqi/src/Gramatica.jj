options{  STATIC = false;  IGNORE_CASE = true;  OUTPUT_DIRECTORY = "br\\com\\joqi\\parser";}PARSER_BEGIN(Parser)package br.com.joqi.parser;import java.io.FileInputStream;import br.com.joqi.semantico.consulta.Query;import br.com.joqi.semantico.consulta.QueryUtils;import br.com.joqi.semantico.consulta.projecao.Projecao;import br.com.joqi.semantico.consulta.projecao.ProjecaoAritmetica;import br.com.joqi.semantico.consulta.projecao.ProjecaoBooleana;import br.com.joqi.semantico.consulta.projecao.ProjecaoCampo;import br.com.joqi.semantico.consulta.projecao.ProjecaoDate;import br.com.joqi.semantico.consulta.projecao.ProjecaoString;import br.com.joqi.semantico.consulta.relacao.Relacao;import br.com.joqi.semantico.consulta.restricao.IPossuiRestricoes;import br.com.joqi.semantico.consulta.restricao.Restricao;import br.com.joqi.semantico.consulta.restricao.RestricaoConjunto;import br.com.joqi.semantico.consulta.restricao.RestricaoSimples;import br.com.joqi.semantico.consulta.restricao.operadorlogico.OperadorLogico;import br.com.joqi.semantico.consulta.restricao.operadorlogico.OperadorLogicoAnd;import br.com.joqi.semantico.consulta.restricao.operadorlogico.OperadorLogicoOr;import br.com.joqi.semantico.consulta.restricao.operadorrelacional.Diferente;import br.com.joqi.semantico.consulta.restricao.operadorrelacional.Entre;import br.com.joqi.semantico.consulta.restricao.operadorrelacional.Igual;import br.com.joqi.semantico.consulta.restricao.operadorrelacional.IgualBooleano;import br.com.joqi.semantico.consulta.restricao.operadorrelacional.IgualParcial;import br.com.joqi.semantico.consulta.restricao.operadorrelacional.Maior;import br.com.joqi.semantico.consulta.restricao.operadorrelacional.MaiorIgual;import br.com.joqi.semantico.consulta.restricao.operadorrelacional.Menor;import br.com.joqi.semantico.consulta.restricao.operadorrelacional.MenorIgual;import br.com.joqi.semantico.consulta.restricao.operadorrelacional.Nulo;import br.com.joqi.semantico.consulta.restricao.operadorrelacional.OperadorRelacional;import br.com.joqi.semantico.consulta.util.JoqiUtil;import br.com.joqi.semantico.exception.ClausulaFromException;public class Parser{  private static Query query = new Query();  public static void main(String [] args) throws Exception  {    Parser parser = new Parser(new FileInputStream("teste.txt"));    parser.executa();    query.getResultado();  }}PARSER_END(Parser)SKIP :{  " "| "\r"| "\t"| "\n"}/*Palavras reservadas*/TOKEN :{  < SELECT : "select" >| < FROM : "from" >| < WHERE : "where" >| < ORDER_BY : "order by" >| < AND : "and" >| < OR : "or" >| < NOT : "not" >| < LIKE : "like" >| < IS : "is" >| < NULL : "null" >| < TRUE : "true" >| < FALSE : "false" >| < AS : "as" >| < BETWEEN : "between" >}/*Funcoes aritmeticas*/TOKEN :{  < COUNT : "count" >| < SUM : "sum" >| < AVG : "avg" >| < MIN : "min" >| < MAX : "max" >| < ABS : "abs" >| < POWER : "power" >| < SQRT : "sqrt" >}/*Funcoes string*/TOKEN :{  < CONCAT : "concat" >| < LOWERCASE : "lowercase" >| < UPPERCASE : "uppercase" >| < TRIM : "trim" >| < FORMAT_DATE : "formatdate" >| < FORMAT_NUMBER : "formatnumber" >| < DATE : "date" >}/*Operadores*/TOKEN :{  < MAIS : "+" >| < MENOS : "-" >| < MULTIPLICA : "*" >| < DIVIDE : "/" >| < RESTO_DIVISAO : "%" >| < IGUAL : "=" >| < MAIOR : ">" >| < MENOR : "<" >| < MAIOR_IGUAL : ">=" >| < MENOR_IGUAL : "<=" >| < DIFERENTE : "<>" >}/*Outros tokens*/TOKEN :{  < PONTO : "." >| < VIRGULA : "," >| < PONTO_E_VIRGULA : ";" >| < ASPA : "'" >| < ABRE_PARENTESE : "(" >| < FECHA_PARENTESE : ")" >}TOKEN :{  < #DIGITOS : ([ "0"-"9" ])+ >| < NUMERO : < DIGITOS > (< PONTO > < DIGITOS >)? >| < #INICIO_IDENTIFICADOR : [ "a"-"z", "A"-"Z", "_" ] >| < IDENTIFICADOR :    < INICIO_IDENTIFICADOR >    (      < INICIO_IDENTIFICADOR >    | < DIGITOS >    )* >| < TEXTO : < ASPA > (~[ "'" ])* < ASPA > >}/**************************************//* Definicao da expressao aritimetica *//**************************************/double expressaoAritmeticaAux() :{  Token token;  double retorno;}{  (    token = < NUMERO >    {      retorno = Double.valueOf(token.image);    }//  | < ABRE_PARENTESE > retorno = expressaoAritmetica() < FECHA_PARENTESE >  )  //  {    return retorno;  }}double expressaoAritmetica() :{  double retorno;}{  retorno = expressaoAritmeticaAux()  (    < MAIS >    {      retorno += expressaoAritmeticaAux();    }  | < MENOS >    {      retorno -= expressaoAritmeticaAux();    }  | < MULTIPLICA >    {      retorno *= expressaoAritmeticaAux();    }  | < DIVIDE >    {      retorno /= expressaoAritmeticaAux();    }  )*  //  {    return retorno;  }}/*************************************************************//* Definicoes das funcoes que a linguagem ira disponibilizar *//*************************************************************/void count() :{}{  < COUNT > < ABRE_PARENTESE > projecaoCampo() < FECHA_PARENTESE >}void sum() :{}{  < SUM > < ABRE_PARENTESE > projecaoCampo() < FECHA_PARENTESE >}void avg() :{}{  < AVG > < ABRE_PARENTESE > projecaoCampo() < FECHA_PARENTESE >}void min() :{}{  < MIN > < ABRE_PARENTESE > projecaoCampo() < FECHA_PARENTESE >}void max() :{}{  < MAX > < ABRE_PARENTESE > projecaoCampo() < FECHA_PARENTESE >}/**************************************************************//* Definicao dos tipos de projecao    						  *//* 															  *//* projecaoCampo() = nome do campo    						  *//* projecaoAritmetica() = projecao com uma formula aritmetica *//* projecaoString() = projecao de uma string qualquer    	  *//* projecaoAux() = retorna qualquer uma das tres acima    	  *//**************************************************************/ProjecaoCampo projecaoCampo() :{  Token relacao = null;  Token nome = null;}{  (    LOOKAHEAD(2)    relacao = < IDENTIFICADOR > < PONTO > nome = < IDENTIFICADOR >  | nome = < IDENTIFICADOR >  )  {    ProjecaoCampo projecao = new ProjecaoCampo(nome.image);    if (relacao != null)    {      projecao.setRelacao(relacao.image);    }    return projecao;  }}ProjecaoAritmetica projecaoAritmetica() :{  double valorExpressao;}{  valorExpressao = expressaoAritmetica()  {    return new ProjecaoAritmetica(valorExpressao);  }}ProjecaoString projecaoString() :{  Token texto;}{  texto = < TEXTO >  {    return new ProjecaoString(texto.image);  }}ProjecaoDate projecaoDate() :{  ProjecaoString dataStr;}{  < DATE > < ABRE_PARENTESE > dataStr = projecaoString() < FECHA_PARENTESE >  {    return new ProjecaoDate(JoqiUtil.asDate(dataStr.getValor()));  }}Projecao projecaoAux() :{  Projecao projecao;}{  (    projecao = projecaoCampo()  | projecao = projecaoAritmetica()  | projecao = projecaoString()  | projecao = projecaoDate()  )  {    return projecao;  }}/************************************************//* Define uma relacao com nome e apelido        *//************************************************/Relacao relacao() :{  Token nome = null;  Token apelido = null;}{  nome = < IDENTIFICADOR >  [    [ < AS > ] apelido = < IDENTIFICADOR >  ]  {    Relacao relacao = new Relacao(nome.image);    if (apelido != null)    {      relacao.setApelido(apelido.image);    }    return relacao;  }}/**********************************************************//* Definicao das restricoes (operacoes logicas) que serao *//* usadas na clausula WHERE.							  *//* A restricao pode ser uma formula '[not] valor = valor' *//* ou um comando do tipo '[not] valor is null' 			  *//**********************************************************/Projecao operandoRestricao() :{  Projecao operando;}{  operando = projecaoAux()  {    return operando;  }}RestricaoSimples restricao(boolean negacao, OperadorLogico operadorLogico) :{  Projecao operando1;  Projecao operando2;  Projecao operandoAux;  OperadorRelacional operadorRelacional;}{  operando1 = operandoRestricao()  (    (      (        < IGUAL >        {          operadorRelacional = new Igual();        }      | < MAIOR >        {          operadorRelacional = new Maior();        }      | < MENOR >        {          operadorRelacional = new Menor();        }      | < MAIOR_IGUAL >        {          operadorRelacional = new MaiorIgual();        }      | < MENOR_IGUAL >        {          operadorRelacional = new MenorIgual();        }      | < DIFERENTE >        {          operadorRelacional = new Diferente();        }      | < LIKE >        {          operadorRelacional = new IgualParcial();        }      |        (          < BETWEEN >          {            operadorRelacional = new Entre(operando1);          }          operando1 = operandoRestricao() < AND >        )      )      operando2 = operandoRestricao()    )  |    (      < IS >      (        (          < NULL >          {            operadorRelacional = new Nulo();            operando2 = new ProjecaoString(null);          }        )      |        (          (            < TRUE >            {              operando2 = new ProjecaoBooleana(true);            }          | < FALSE >            {              operando2 = new ProjecaoBooleana(false);            }          )          {            operadorRelacional = new IgualBooleano();          }        )      )    )  )  {    return new RestricaoSimples(negacao, operando1, operando2, operadorRelacional, operadorLogico);  }}/************************************************//* Define como eh formada a clausula SELECT	    *//* Seus elementos sao quaisquer projecoes	    *//************************************************/Projecao projecao() :{  Projecao projecao;  Token apelido = null;}{  projecao = projecaoAux()  [    [ < AS > ] apelido = < IDENTIFICADOR >  ]  {    if (apelido != null)    {      projecao.setApelido(apelido.image);    }    return projecao;  }}void select() :{}{  < SELECT >  {    query.addProjecao(projecao());  }  (    < VIRGULA >    {      query.addProjecao(projecao());    }  )*}/****************************************************//* Define como eh formada a clausula FROM	        *//* Seus elementos sao os nomes das relacoes         *//****************************************************/void from() throws ClausulaFromException :{}{  < FROM >  {    query.addRelacao(relacao());  }  (    < VIRGULA >    {      query.addRelacao(relacao());    }  )*}/*******************************************//* Define como eh formada a clausula WHERE *//* Seus elementos sao as restricoes		   *//*******************************************/void where() :{}{  < WHERE > restricoes(null)}/********************************************************//* Faz a leitura das restricoes que irao compor o WHERE *//********************************************************/void restricoes(RestricaoConjunto restricaoConjunto) :{  OperadorLogico operadorLogico;}{  //Le a primeira restricao  restricoesAux(null, restricaoConjunto)  (    (      < AND >      {        operadorLogico = new OperadorLogicoAnd();      }    | < OR >      {        operadorLogico = new OperadorLogicoOr();      }    )    //Le as outras restricoes, incluindo o operador logico    restricoesAux(operadorLogico, restricaoConjunto)  )*}void restricoesAux(OperadorLogico operadorLogico, RestricaoConjunto restricaoConjuntoMae) :{  RestricaoSimples restricaoSimples = null;  RestricaoConjunto restricaoConjunto = null;  boolean negacao = false;}{  [    < NOT >    {      negacao = true;    }  ]  (    LOOKAHEAD(projecaoAux())    (      //Restricao sem parentese      restricaoSimples = restricao(negacao, operadorLogico)      {        //Inclui dentro de um conjunto de restricoes, se existir um conjunto        IPossuiRestricoes listaRestricoes = restricaoConjuntoMae;        if (restricaoConjuntoMae == null)        {          //Inclui direto na lista de restricoes da query                               listaRestricoes = query;        }        //         if (restricaoSimples.getOperadorRelacional().getClass() == Entre.class)        {          RestricaoSimples [ ] betweenSeparado = QueryUtils.divideRestricaoBetween(restricaoSimples);          //          listaRestricoes.addRestricao(betweenSeparado [ 0 ]);          listaRestricoes.addRestricao(betweenSeparado [ 1 ]);        }        else        {          listaRestricoes.addRestricao(restricaoSimples);        }      }    )  |    (      {        /*        Cria um novo conjunto de restricoes. Este caso eh especial para        restricoes entre parenteses. Cada vez que um parentese for aberto, um        conjunto de restricoes sera criado. Isto foi feito para que seja possivel        utilizar o operador NOT para um conjunto de restricoes entre parenteses        Um conjunto de restricoes pode conter tanto uma restricao simples (ex: 1=1)        como outro conjunto de restricoes        */        restricaoConjunto = new RestricaoConjunto(negacao, operadorLogico);      }      < ABRE_PARENTESE > restricoes(restricaoConjunto) < FECHA_PARENTESE >      {        if (restricaoConjunto.getRestricoes().size() > 0)        {          Restricao restricaoAdicionar = restricaoConjunto;          if (restricaoConjunto.getRestricoes().size() == 1)          {            Restricao restricaoUnica = restricaoConjunto.getRestricoes().get(0);            if (restricaoUnica.getClass() == RestricaoSimples.class)            {              restricaoSimples = (RestricaoSimples) restricaoUnica;              restricaoSimples.setOperadorLogico(restricaoConjunto.getOperadorLogico());              restricaoSimples.setNegacao(restricaoConjunto.isNegacao());              restricaoAdicionar = restricaoSimples;            }          }          //          if (restricaoConjuntoMae != null)          {            restricaoConjuntoMae.addRestricao(restricaoAdicionar);          }          else          {            query.addRestricao(restricaoAdicionar);          }        }      }    )  )}/********************************************************//* Definicao da clausula de ordenacao ORDER BY		    *//********************************************************/Projecao valorOrderBy() :{  Projecao valorOrderBy;}{  valorOrderBy = projecaoAux()  {    return valorOrderBy;  }}void orderBy() :{}{  < ORDER_BY > valorOrderBy()  (    < VIRGULA > valorOrderBy()  )*}/**********************************//* EXECUCAO DO LEXICO E DO PARSER *//**********************************/void executa() throws ClausulaFromException :{}{  [ select() ] from() [ where() ] [ orderBy() ] [ < PONTO_E_VIRGULA > ] < EOF >}
/* Generated By:JavaCC: Do not edit this line. Parser.java */
package br.com.joqi.parser;
import java.io.StringReader;
import br.com.joqi.semantico.consulta.Query;
import br.com.joqi.semantico.consulta.QueryUtils;
import br.com.joqi.semantico.consulta.agrupamento.agregacao.Avg;
import br.com.joqi.semantico.consulta.agrupamento.agregacao.Count;
import br.com.joqi.semantico.consulta.agrupamento.agregacao.FuncaoAgregacao;
import br.com.joqi.semantico.consulta.agrupamento.agregacao.Max;
import br.com.joqi.semantico.consulta.agrupamento.agregacao.Min;
import br.com.joqi.semantico.consulta.agrupamento.agregacao.Sum;
import br.com.joqi.semantico.consulta.ordenacao.ItemOrdenacao.TipoOrdenacao;
import br.com.joqi.semantico.consulta.projecao.Projecao;
import br.com.joqi.semantico.consulta.projecao.ProjecaoAritmetica;
import br.com.joqi.semantico.consulta.projecao.ProjecaoBooleana;
import br.com.joqi.semantico.consulta.projecao.ProjecaoCampo;
import br.com.joqi.semantico.consulta.projecao.ProjecaoDate;
import br.com.joqi.semantico.consulta.projecao.ProjecaoFuncaoAgregacao;
import br.com.joqi.semantico.consulta.projecao.ProjecaoString;
import br.com.joqi.semantico.consulta.relacao.Relacao;
import br.com.joqi.semantico.consulta.restricao.IPossuiRestricoes;
import br.com.joqi.semantico.consulta.restricao.Restricao;
import br.com.joqi.semantico.consulta.restricao.RestricaoConjunto;
import br.com.joqi.semantico.consulta.restricao.RestricaoSimples;
import br.com.joqi.semantico.consulta.restricao.operadorlogico.OperadorLogico;
import br.com.joqi.semantico.consulta.restricao.operadorlogico.OperadorLogicoAnd;
import br.com.joqi.semantico.consulta.restricao.operadorlogico.OperadorLogicoOr;
import br.com.joqi.semantico.consulta.restricao.operadorrelacional.Diferente;
import br.com.joqi.semantico.consulta.restricao.operadorrelacional.Entre;
import br.com.joqi.semantico.consulta.restricao.operadorrelacional.Igual;
import br.com.joqi.semantico.consulta.restricao.operadorrelacional.IgualBooleano;
import br.com.joqi.semantico.consulta.restricao.operadorrelacional.IgualParcial;
import br.com.joqi.semantico.consulta.restricao.operadorrelacional.Maior;
import br.com.joqi.semantico.consulta.restricao.operadorrelacional.MaiorIgual;
import br.com.joqi.semantico.consulta.restricao.operadorrelacional.Menor;
import br.com.joqi.semantico.consulta.restricao.operadorrelacional.MenorIgual;
import br.com.joqi.semantico.consulta.restricao.operadorrelacional.Nulo;
import br.com.joqi.semantico.consulta.restricao.operadorrelacional.OperadorRelacional;
import br.com.joqi.semantico.consulta.util.JoqiUtil;
import br.com.joqi.semantico.exception.ClausulaFromException;
import br.com.joqi.semantico.exception.RelacaoInexistenteException;

public class Parser implements ParserConstants {
  private Query query = null;

  public Parser(Query query, String queryString)
  {
    this (new StringReader(queryString));
    this.query = query;
  }

/**************************************/
/* Definicao da expressao aritimetica */
/**************************************/
  final public double expressaoAritmeticaAux() throws ParseException {
  Token token;
  double retorno;
    token = jj_consume_token(NUMERO);
      retorno = Double.valueOf(token.image);
    {if (true) return retorno;}
    throw new Error("Missing return statement in function");
  }

  final public double expressaoAritmetica() throws ParseException {
  double retorno;
    retorno = expressaoAritmeticaAux();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MAIS:
      case MENOS:
      case MULTIPLICA:
      case DIVIDE:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MAIS:
        jj_consume_token(MAIS);
      retorno += expressaoAritmeticaAux();
        break;
      case MENOS:
        jj_consume_token(MENOS);
      retorno -= expressaoAritmeticaAux();
        break;
      case MULTIPLICA:
        jj_consume_token(MULTIPLICA);
      retorno *= expressaoAritmeticaAux();
        break;
      case DIVIDE:
        jj_consume_token(DIVIDE);
      retorno /= expressaoAritmeticaAux();
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return retorno;}
    throw new Error("Missing return statement in function");
  }

/********************************************************/
/* Definicoes das funcoes de agregacao que a linguagem  */
/* ira disponibilizar 									*/
/********************************************************/
  final public FuncaoAgregacao funcaoAgregacao() throws ParseException {
  FuncaoAgregacao funcao;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COUNT:
      jj_consume_token(COUNT);
      funcao = new Count();
      break;
    case SUM:
      jj_consume_token(SUM);
      funcao = new Sum();
      break;
    case MIN:
      jj_consume_token(MIN);
      funcao = new Min();
      break;
    case MAX:
      jj_consume_token(MAX);
      funcao = new Max();
      break;
    case AVG:
      jj_consume_token(AVG);
      funcao = new Avg();
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(ABRE_PARENTESE);
    funcao.setCampo(projecaoCampo());
    jj_consume_token(FECHA_PARENTESE);
    {if (true) return funcao;}
    throw new Error("Missing return statement in function");
  }

/**************************************************************/
/* Definicao dos tipos de projecao    						  */
/* 															  */
/* projecaoCampo() = nome do campo    						  */
/* projecaoAritmetica() = projecao com uma formula aritmetica */
/* projecaoString() = projecao de uma string qualquer    	  */
/**************************************************************/
  final public ProjecaoCampo projecaoCampo() throws ParseException {
  Token relacao = null;
  Token nome = null;
    if (jj_2_1(2)) {
      relacao = jj_consume_token(IDENTIFICADOR);
      jj_consume_token(PONTO);
      nome = jj_consume_token(IDENTIFICADOR);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFICADOR:
        nome = jj_consume_token(IDENTIFICADOR);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    ProjecaoCampo projecao = new ProjecaoCampo(nome.image);
    if (relacao != null)
    {
      projecao.setRelacao(relacao.image);
    }
    {if (true) return projecao;}
    throw new Error("Missing return statement in function");
  }

  final public ProjecaoAritmetica projecaoAritmetica() throws ParseException {
  double valorExpressao;
    valorExpressao = expressaoAritmetica();
    {if (true) return new ProjecaoAritmetica(valorExpressao);}
    throw new Error("Missing return statement in function");
  }

  final public ProjecaoString projecaoString() throws ParseException {
  Token texto;
    texto = jj_consume_token(TEXTO);
    {if (true) return new ProjecaoString(texto.image);}
    throw new Error("Missing return statement in function");
  }

  final public ProjecaoDate projecaoDate() throws ParseException {
  ProjecaoString dataStr;
    jj_consume_token(DATE);
    jj_consume_token(ABRE_PARENTESE);
    dataStr = projecaoString();
    jj_consume_token(FECHA_PARENTESE);
    {if (true) return new ProjecaoDate(JoqiUtil.asDate(dataStr.getValor()));}
    throw new Error("Missing return statement in function");
  }

  final public ProjecaoFuncaoAgregacao projecaoFuncaoAgregacao() throws ParseException {
    {if (true) return new ProjecaoFuncaoAgregacao(funcaoAgregacao());}
    throw new Error("Missing return statement in function");
  }

/************************************************/
/* Define uma relacao com nome e apelido        */
/************************************************/
  final public Relacao relacao() throws ParseException {
  Token nome = null;
  Token apelido = null;
    nome = jj_consume_token(IDENTIFICADOR);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
    case IDENTIFICADOR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        jj_consume_token(AS);
        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
      apelido = jj_consume_token(IDENTIFICADOR);
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    Relacao relacao = new Relacao(nome.image);
    if (apelido != null)
    {
      relacao.setApelido(apelido.image);
    }
    {if (true) return relacao;}
    throw new Error("Missing return statement in function");
  }

/**********************************************************/
/* Definicao das restricoes (operacoes logicas) que serao */
/* usadas na clausula WHERE.							  */
/* A restricao pode ser uma formula '[not] valor = valor' */
/* ou um comando do tipo '[not] valor is null' 			  */
/**********************************************************/
  final public Projecao operando() throws ParseException {
  Projecao operando;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFICADOR:
      operando = projecaoCampo();
      break;
    case NUMERO:
      operando = projecaoAritmetica();
      break;
    case TEXTO:
      operando = projecaoString();
      break;
    case DATE:
      operando = projecaoDate();
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return operando;}
    throw new Error("Missing return statement in function");
  }

  final public RestricaoSimples restricao(boolean negacao, OperadorLogico operadorLogico) throws ParseException {
  Projecao operando1;
  Projecao operando2;
  Projecao operandoAux;
  OperadorRelacional operadorRelacional;
    operando1 = operando();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LIKE:
    case BETWEEN:
    case IGUAL:
    case MAIOR:
    case MENOR:
    case MAIOR_IGUAL:
    case MENOR_IGUAL:
    case DIFERENTE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IGUAL:
        jj_consume_token(IGUAL);
          operadorRelacional = new Igual();
        break;
      case MAIOR:
        jj_consume_token(MAIOR);
          operadorRelacional = new Maior();
        break;
      case MENOR:
        jj_consume_token(MENOR);
          operadorRelacional = new Menor();
        break;
      case MAIOR_IGUAL:
        jj_consume_token(MAIOR_IGUAL);
          operadorRelacional = new MaiorIgual();
        break;
      case MENOR_IGUAL:
        jj_consume_token(MENOR_IGUAL);
          operadorRelacional = new MenorIgual();
        break;
      case DIFERENTE:
        jj_consume_token(DIFERENTE);
          operadorRelacional = new Diferente();
        break;
      case LIKE:
        jj_consume_token(LIKE);
          operadorRelacional = new IgualParcial();
        break;
      case BETWEEN:
        jj_consume_token(BETWEEN);
            operadorRelacional = new Entre(operando1);
        operando1 = operando();
        jj_consume_token(AND);
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      operando2 = operando();
      break;
    case IS:
      jj_consume_token(IS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NULL:
        jj_consume_token(NULL);
            operadorRelacional = new Nulo();
            operando2 = new ProjecaoString(null);
        break;
      case TRUE:
      case FALSE:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TRUE:
          jj_consume_token(TRUE);
              operando2 = new ProjecaoBooleana(true);
          break;
        case FALSE:
          jj_consume_token(FALSE);
              operando2 = new ProjecaoBooleana(false);
          break;
        default:
          jj_la1[8] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
            operadorRelacional = new IgualBooleano();
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return new RestricaoSimples(negacao, operando1, operando2, operadorRelacional, operadorLogico);}
    throw new Error("Missing return statement in function");
  }

/************************************************/
/* Define como eh formada a clausula SELECT	    */
/* Seus elementos sao quaisquer projecoes	    */
/************************************************/
  final public Projecao projecao() throws ParseException {
  Projecao projecao;
  Token apelido = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFICADOR:
      projecao = projecaoCampo();
      break;
    case NUMERO:
      projecao = projecaoAritmetica();
      break;
    case TEXTO:
      projecao = projecaoString();
      break;
    case DATE:
      projecao = projecaoDate();
      break;
    default:
      jj_la1[11] = jj_gen;
      projecao = projecaoFuncaoAgregacao();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
    case IDENTIFICADOR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        jj_consume_token(AS);
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      apelido = jj_consume_token(IDENTIFICADOR);
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
    if (apelido != null)
    {
      projecao.setApelido(apelido.image);
    }
    {if (true) return projecao;}
    throw new Error("Missing return statement in function");
  }

  final public void select() throws ParseException {
    jj_consume_token(SELECT);
    query.addProjecao(projecao());
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VIRGULA:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_2;
      }
      jj_consume_token(VIRGULA);
      query.addProjecao(projecao());
    }
  }

/****************************************************/
/* Define como eh formada a clausula FROM	        */
/* Seus elementos sao os nomes das relacoes         */
/****************************************************/
  final public void from() throws ParseException, ClausulaFromException, RelacaoInexistenteException {
    jj_consume_token(FROM);
    query.addRelacao(relacao());
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VIRGULA:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_3;
      }
      jj_consume_token(VIRGULA);
      query.addRelacao(relacao());
    }
  }

/*******************************************/
/* Define como eh formada a clausula WHERE */
/* Seus elementos sao as restricoes		   */
/*******************************************/
  final public void where() throws ParseException {
    jj_consume_token(WHERE);
    restricoes(null);
  }

/********************************************************/
/* Faz a leitura das restricoes que irao compor o WHERE */
/********************************************************/
  final public void restricoes(RestricaoConjunto restricaoConjunto) throws ParseException {
  OperadorLogico operadorLogico;
    restricoesAux(null, restricaoConjunto);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
      case OR:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_4;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        jj_consume_token(AND);
        operadorLogico = new OperadorLogicoAnd();
        break;
      case OR:
        jj_consume_token(OR);
        operadorLogico = new OperadorLogicoOr();
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      restricoesAux(operadorLogico, restricaoConjunto);
    }
  }

  final public void restricoesAux(OperadorLogico operadorLogico, RestricaoConjunto restricaoConjuntoMae) throws ParseException {
  RestricaoSimples restricaoSimples = null;
  RestricaoConjunto restricaoConjunto = null;
  boolean negacao = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
      negacao = true;
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    if (jj_2_2(2147483647)) {
      //Restricao sem parentese
            restricaoSimples = restricao(negacao, operadorLogico);
        //Inclui dentro de um conjunto de restricoes, se existir um conjunto
        IPossuiRestricoes listaRestricoes = restricaoConjuntoMae;
        if (restricaoConjuntoMae == null)
        {
          //Inclui direto na lista de restricoes da query                     
          listaRestricoes = query;
        }
        // 
        if (restricaoSimples.getOperadorRelacional().getClass() == Entre.class)
        {
          RestricaoSimples [ ] betweenSeparado = QueryUtils.divideRestricaoBetween(restricaoSimples);
          //
          listaRestricoes.addRestricao(betweenSeparado [ 0 ]);
          listaRestricoes.addRestricao(betweenSeparado [ 1 ]);
        }
        else
        {
          listaRestricoes.addRestricao(restricaoSimples);
        }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABRE_PARENTESE:
        /*
        Cria um novo conjunto de restricoes. Este caso eh especial para
        restricoes entre parenteses. Cada vez que um parentese for aberto, um
        conjunto de restricoes sera criado. Isto foi feito para que seja possivel
        utilizar o operador NOT para um conjunto de restricoes entre parenteses
        Um conjunto de restricoes pode conter tanto uma restricao simples (ex: 1=1)
        como outro conjunto de restricoes
        */
        restricaoConjunto = new RestricaoConjunto(negacao, operadorLogico);
        jj_consume_token(ABRE_PARENTESE);
        restricoes(restricaoConjunto);
        jj_consume_token(FECHA_PARENTESE);
        if (restricaoConjunto.getRestricoes().size() > 0)
        {
          Restricao restricaoAdicionar = restricaoConjunto;
          if (restricaoConjunto.getRestricoes().size() == 1)
          {
            Restricao restricaoUnica = restricaoConjunto.getRestricoes().get(0);
            if (restricaoUnica.getClass() == RestricaoSimples.class)
            {
              restricaoSimples = (RestricaoSimples) restricaoUnica;
              restricaoSimples.setOperadorLogico(restricaoConjunto.getOperadorLogico());
              /*restricaoSimples.setNegacao(restricaoConjunto.isNegacao());*/
              restricaoAdicionar = restricaoSimples;
            }
          }
          //
          if (restricaoConjuntoMae != null)
          {
            restricaoConjuntoMae.addRestricao(restricaoAdicionar);
          }
          else
          {
            query.addRestricao(restricaoAdicionar);
          }
        }
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

/********************************************************/
/* Definicao da clausula de ordenacao ORDER BY		    */
/********************************************************/
  final public TipoOrdenacao tipoOrdenacao() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASC:
    case DESC:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASC:
        jj_consume_token(ASC);
      {if (true) return TipoOrdenacao.ASC;}
        break;
      case DESC:
        jj_consume_token(DESC);
      {if (true) return TipoOrdenacao.DESC;}
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
    {if (true) return TipoOrdenacao.ASC;}
    throw new Error("Missing return statement in function");
  }

  final public void orderBy() throws ParseException {
    jj_consume_token(ORDER_BY);
    query.addItemOrdenacao(operando(), tipoOrdenacao());

    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VIRGULA:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_5;
      }
      jj_consume_token(VIRGULA);
      query.addItemOrdenacao(operando(), tipoOrdenacao());
    }
  }

/********************************************************/
/* Definicao da clausula de agrupamento GROUP BY        */
/********************************************************/
  final public void groupBy() throws ParseException {
    jj_consume_token(GROUP_BY);
    query.addCampoAgrupamento(operando());

    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VIRGULA:
        ;
        break;
      default:
        jj_la1[23] = jj_gen;
        break label_6;
      }
      jj_consume_token(VIRGULA);
      query.addCampoAgrupamento(operando());
    }
  }

/**********************************/
/* EXECUCAO DO LEXICO E DO PARSER */
/**********************************/
  final public void executa() throws ParseException, ClausulaFromException, RelacaoInexistenteException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SELECT:
      select();
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    from();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      where();
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GROUP_BY:
      groupBy();
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ORDER_BY:
      orderBy();
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PONTO_E_VIRGULA:
      jj_consume_token(PONTO_E_VIRGULA);
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    jj_consume_token(0);
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_3R_16() {
    if (jj_3R_17()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_18()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(IDENTIFICADOR)) return true;
    if (jj_scan_token(PONTO)) return true;
    if (jj_scan_token(IDENTIFICADOR)) return true;
    return false;
  }

  private boolean jj_3R_11() {
    if (jj_3R_15()) return true;
    return false;
  }

  private boolean jj_3R_10() {
    if (jj_3R_14()) return true;
    return false;
  }

  private boolean jj_3R_12() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_1()) {
    jj_scanpos = xsp;
    if (jj_scan_token(55)) return true;
    }
    return false;
  }

  private boolean jj_3R_9() {
    if (jj_3R_13()) return true;
    return false;
  }

  private boolean jj_3R_8() {
    if (jj_3R_12()) return true;
    return false;
  }

  private boolean jj_3R_17() {
    if (jj_scan_token(NUMERO)) return true;
    return false;
  }

  private boolean jj_3R_7() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_8()) {
    jj_scanpos = xsp;
    if (jj_3R_9()) {
    jj_scanpos = xsp;
    if (jj_3R_10()) {
    jj_scanpos = xsp;
    if (jj_3R_11()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_15() {
    if (jj_scan_token(DATE)) return true;
    if (jj_scan_token(ABRE_PARENTESE)) return true;
    if (jj_3R_14()) return true;
    if (jj_scan_token(FECHA_PARENTESE)) return true;
    return false;
  }

  private boolean jj_3R_22() {
    if (jj_scan_token(DIVIDE)) return true;
    return false;
  }

  private boolean jj_3R_14() {
    if (jj_scan_token(TEXTO)) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_7()) return true;
    return false;
  }

  private boolean jj_3R_21() {
    if (jj_scan_token(MULTIPLICA)) return true;
    return false;
  }

  private boolean jj_3R_20() {
    if (jj_scan_token(MENOS)) return true;
    return false;
  }

  private boolean jj_3R_13() {
    if (jj_3R_16()) return true;
    return false;
  }

  private boolean jj_3R_18() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_19()) {
    jj_scanpos = xsp;
    if (jj_3R_20()) {
    jj_scanpos = xsp;
    if (jj_3R_21()) {
    jj_scanpos = xsp;
    if (jj_3R_22()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_19() {
    if (jj_scan_token(MAIS)) return true;
    return false;
  }

  /** Generated Token Manager. */
  public ParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[29];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0xf800000,0x0,0x200000,0x200000,0x0,0x410000,0x180000,0x1c0000,0x430000,0x0,0x200000,0x200000,0x0,0x0,0x6000,0x6000,0x8000,0x0,0x1800,0x1800,0x0,0x0,0x20,0x80,0x200,0x400,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x78,0x78,0x0,0x800000,0x0,0x800000,0x1a00004,0x3f00,0x0,0x0,0x3f00,0x1a00004,0x0,0x800000,0x8000,0x8000,0x0,0x0,0x0,0x40000,0x0,0x0,0x8000,0x8000,0x0,0x0,0x0,0x0,0x10000,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[2];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public Parser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Parser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public Parser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[57];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 29; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 57; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 2; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
